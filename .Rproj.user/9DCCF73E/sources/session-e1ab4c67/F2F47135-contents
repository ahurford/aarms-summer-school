---
title: "Chapter 6 solutions"
output: html_document
---

```{r}
## Settings
library(rjags)
library(coda)

## Specify the model
univariate_regression <- "
model{

  beta ~ dmnorm(b0,Vb)  	## multivariate Normal prior on vector of regression params

  for(i in 1:n){
	  log(mu[i]) <- beta[1]+beta[2]*TDR[i]     ## process model   	## process model
	  y[i]  ~ dpois(mu[i])		        ## data model
  }
}
"

## load the data
setwd("/Users/ahurford/Desktop/Work/Teaching/AARMS summer school docs/EF_Activities")
load("data/Ch06.RData")
data <- list(TDR = TDR, y = y, n = n)

## specify priors
data$b0 <- as.vector(c(0,0))      ## regression beta means
data$Vb <- solve(diag(10000,2))   ## regression beta precisions

## initial conditions
nchain = 3
inits <- list()
for(i in 1:nchain){
  inits[[i]] <- list(beta = rnorm(2,1,4))
}

#MCMC loop
j.model2   <- jags.model(file = textConnection(univariate_regression),
                        data = data,
                        inits = inits,
                        n.chains = nchain)

jags.out   <- coda.samples (model = j.model2,
                           variable.names = c("beta"),
                           n.iter = 10000)


plot(jags.out)
GBR <- gelman.plot(jags.out)
burnin = 5000                                   ## determine convergence
jags.burn <- window(jags.out, start = burnin)  ## remove burn-in
plot(jags.burn) 
GBR <- gelman.plot(jags.burn) # >1.1 not converged; <1.05 good
acfplot(jags.burn)
effectiveSize(jags.burn)
cumuplot(jags.burn, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))
summary(jags.burn)
var.mat <- as.matrix(jags.burn)
pairs(var.mat)	## pairs plot to evaluate parameter correlation
cor(var.mat)    ## correlation matrix among model parameters
summary(glm(y ~ TDR, family = "poisson"))
xpred <- seq(min(TDR), max(TDR), (max(TDR)-min(TDR))/100)
plot(TDR,log(y))
for(i in 1:10){
  lines(xpred, var.mat[i,"beta[1]"] + var.mat[i,"beta[2]"]*xpred)
}
```

```{r}
## credible and prediction intervals
nsamp <- 5000
samp <- sample.int(nrow(var.mat),nsamp)
npred <- length(xpred)				##      make predictions for
ypred <- matrix(0.0,nrow=nsamp,ncol=npred)	## storage for predictive interval
ycred <- matrix(0.0,nrow=nsamp,ncol=npred)	## storage for credible interval
```

```{r}
for(g in seq_len(nsamp)){
  theta = var.mat[samp[g],]
  ycred[g,] <- exp(theta["beta[1]"] + theta["beta[2]"]*xpred)
  ypred[g,] <- rpois(npred,ycred[g,])
}
```

```{r}
ci <- apply(ycred,2,quantile,c(0.025,0.5,0.975))
pi <- apply(ypred,2,quantile,c(0.025,0.975))
plot(TDR,y,cex=0.5)
lines(xpred,ci[1,],col=3,lty=2)	## lower CI
lines(xpred,ci[2,],col=3,lwd=3)	## median
lines(xpred,ci[3,],col=3,lty=2)	## upper CI
lines(xpred,pi[1,],col=4,lty=2)	## lower PI
lines(xpred,pi[2,],col=4,lty=2)	## upper PI
```